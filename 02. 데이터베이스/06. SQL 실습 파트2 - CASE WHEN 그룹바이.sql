### RMSE_MAE_EXAMPLE 테이블에서
### ACCURACY =1 – ABS(예측값-실제값) / 예측값 
### 공식을 활용하여
### 정확도를 산출하세요 (소수점 2째자리 반올림)

SELECT A.*,
	   ROUND( 1-ABS(A.FCST-A.ACTUAL) / A.FCST,2)
FROM RMSE_MAE_EXAMPLE A

#### 만약?... FCST가 0 이 있다면?

CREATE TABLE RMSE_MAE_EXAMPLE2 AS
SELECT *
FROM RMSE_MAE_EXAMPLE

INSERT INTO RMSE_MAE_EXAMPLE2
(FCST) VALUES (0)

SELECT A.*,
	   ABS(A.FCST-A.ACTUAL) / A.FCST AS ACCURACY
FROM RMSE_MAE_EXAMPLE2 A
WHERE A.FCST = 0

#### 
SELECT REPLACE('I AM A  BOY','  ',' ') AS TEST 

SELECT CONCAT('PRODUCT_', REPLACE('AAAAAAAAA91','A','')) AS TEST 

SELECT CONCAT('PRODUCT_', REPLACE('AAAAAAAAA91',' ','')) AS TEST 

-- RMSE_MAE_EXAMPLE 테이블에서
-- ACCURACY =
-- 1 – ABS(예측값-실제값) / 예측값 
-- 공식을 활용하여
-- 정확도를 산출하세요 (소수점 2째자리 반올림)
-- STEP1: 1-절대값(예측값 - 실제값) / 예측값 AS ACCURACY
-- STEP2: ROUND( STEP1 , 2)
SELECT
	ROUND( (1 - ABS(A.FCST-A.ACTUAL) / A.FCST ) * 100 ,2) AS ACCURACY,
	A.*
FROM RMSE_MAE_EXAMPLE A

SELECT CAST('1543' AS SIGNED ) * 500 AS SIGNED

SELECT CAST(1543 AS CHAR) AS CHA

SELECT *
FROM KOPO_PRODUCT_VOLUME

DESCRIBE KOPO_PRODUCT_VOLUME

##############################  참고. 날짜 함수 ##################################
## 참고 사이트: https://www.w3schools.com/sql/func_mysql_date_format.asp

SELECT A.*,
	NOW() AS UPDATED_DATE
FROM KOPO_PRODUCT_VOLUME A

SELECT DATE_FORMAT(
			NOW(), '%Y-%m-%d %H:%i:%s'
		) AS formatted_date;

SELECT DATE_FORMAT(
		NOW(), '%Y|%m|%d'
	) AS formatted_date;

##############################  CASE WHEN  ##################################
### CASE #1, CASE #2
### 상한선 30000 하한선 1000
SELECT A.*,
	   CASE WHEN A.QTY < 1000 THEN 1000
	   		WHEN A.QTY < 10000 THEN 10000
	   		ELSE 30000 END AS NEW_QTY
FROM KOPO_CHANNEL_SEASONALITY_NEW A

DROP TABLE RMSE_MAE_EXAMPLE2

#### 만약?... FCST가 0 이 있다면?
CREATE TABLE RMSE_MAE_EXAMPLE2 AS
SELECT *
FROM RMSE_MAE_EXAMPLE

INSERT INTO RMSE_MAE_EXAMPLE2
(FCST) VALUES (0)

### FCST가 0 정확도 NULL...
### FCST = 0 ACCURACY = 0 
### FCST = 0 ACCURACY 아에 배제빼라
SELECT
	1 - ABS(A.FCST - A.ACTUAL) / A.FCST AS CAL,
	ROUND( (1 - ABS(FCST - ACTUAL) / FCST) * 100, 2) AS ACCURACY,
	CASE WHEN A.FCST = 0 THEN 0
		 ELSE ROUND( (1 - ABS(FCST - ACTUAL) / FCST) * 100, 2) END AS REAL_ACCURACY,
	A.*
FROM RMSE_MAE_EXAMPLE2 A
WHERE A.FCST = 0


### 실습문제
-- KOPO_CUSTOMERDATA 테이블에서
-- TOTAL_AMOUNT가 10만 이상인경우 HIGH
-- 이외에는 LOW 라는 CUSTOMER_SEG 컬럼을 생성하세요
SELECT A.*, 
        CASE
                WHEN TOTAL_AMOUNT >= 100000 THEN 'HIGH'
                ELSE 'LOW'
        END AS CUSTOMER_SEG
FROM KOPO_CUSTOMERDATA A;

SELECT A.*, 
        CASE
                WHEN TOTAL_AMOUNT >= 100000 THEN 'HIGH'
                WHEN TOTAL_AMOUNT >= 80000 AND  TOTAL_AMOUNT < 100000 THEN 'MID'
                ELSE 'LOW'
        END AS CUSTOMER_SEG
FROM KOPO_CUSTOMERDATA A;


##############################  집계함수 (GROUP BY)  ##################################
# LEN, SUM, MIN, MAX, AVG
SELECT SUM(QTY)
FROM KOPO_CHANNEL_SEASONALITY_NEW 


SELECT 
	AVG(A.QTY) AS AVG_QTY,
	SUM(A.QTY) AS SUM_QTY,
	MIN(A.QTY) AS MIN_QTY,
	MAX(A.QTY) AS MAX_QTY,
	COUNT(A.QTY) AS COUNT_QTY
FROM KOPO_CHANNEL_SEASONALITY_NEW A

SELECT 
	A.PRODUCT,
	AVG(A.QTY) AS AVG_QTY,
	SUM(A.QTY) AS SUM_QTY
-- 	MIN(A.QTY) AS MIN_QTY,
-- 	MAX(A.QTY) AS MAX_QTY,
-- 	COUNT(A.QTY) AS COUNT_QTY
FROM KOPO_CHANNEL_SEASONALITY_NEW A
WHERE A.REGIONID IN ('A01','A02','A03')
GROUP BY A.PRODUCT
HAVING AVG(A.QTY) > 1000
ORDER BY SUM(QTY) ASC, MIN(QTY) DESC

SELECT 
	A.REGIONID,
	AVG(A.QTY) AS AVG_QTY,
	SUM(A.QTY) AS SUM_QTY,
	MIN(A.QTY) AS MIN_QTY,
	MAX(A.QTY) AS MAX_QTY,
	COUNT(A.QTY) AS COUNT_QTY
FROM KOPO_CHANNEL_SEASONALITY_NEW A
WHERE A.REGIONID IN ('A01', 'A02', 'A03')
GROUP BY A.REGIONID, PRODUCT
HAVING AVG(A.QTY) > 1000
AND MAX(A.QTY) > 80000

# 순서가 중요 WHERE -> GROUP BY -> HAVING -> ORDER BY (항상 마지막) 이렇게 정리하면 될까요


SELECT * 
FROM KOPO_CHANNEL_SEASONALITY_NEW



-- 1. KOPO_CUSTOMERDATA에서 STATE 별 가격의 TOTAL_AMOUNT의 최대값을 구하세요
SELECT A.STATENAME,
	MAX(A.TOTAL_AMOUNT) AS MAX_TOTAL 
FROM KOPO_CUSTOMERDATA A
GROUP BY A.STATENAME
ORDER BY A.STATENAME

-- 2. KOPO_CUSTOMERDATA에서 STATE, GENDER 별 평균 방문횟수(CNT_VISIT)를 구하세요
SELECT A.STATENAME,
                A.GENDER,
                AVG(A.CNT_VIST) AS AVG_VIST 
FROM KOPO_CUSTOMERDATA A
GROUP BY A.STATENAME, A.GENDER
ORDER BY A.STATENAME, A.GENDER

-- 3. [기본조회] KOPO_CHANNEL_SEASONALITY_NEW 테이블에서 
SELECT *
FROM KOPO_CHANNEL_SEASONALITY_NEW
WHERE SUBSTR(YEARWEEK, 5, 2) != 53
AND SUBSTR(YEARWEEK, 1, 4) >= 2015
AND PRODUCT IN ('PRODUCT1', 'PRODUCT2')

SELECT *
FROM KOPO_CHANNEL_SEASONALITY_NEW KCSN 
WHERE YEARWEEK != 53 
AND LEFT(YEARWEEK,4) >= 2015 
AND (PRODUCT LIKE 'PRODUCT1%' OR PRODUCT LIKE 'PRODUCT2%')

--    다음 조건을 만족하는 테이블을 생성 쿼리를 작성하세요 
--    (주차 != 53 AND 연도 >= 2015 AND 상품(PRODUCT1 및 PRODUCT2) 
--    
-- 4. [GROUP-BY] 4번 결과 테이블(KOPO_RESULT1)에서 지역/상품별 평균판매량을 
--    소수점 없이 반올림하여 AVG_QTY 컬럼 값을 SELECT로 생성하는 쿼리를 작성하시오.
CREATE TABLE KOPO_RESULT1 AS
SELECT *
FROM KOPO_CHANNEL_SEASONALITY_NEW KCSN 
WHERE YEARWEEK != 53 
        AND LEFT(YEARWEEK,4) >= 2015 
        AND (PRODUCT LIKE 'PRODUCT1%' OR PRODUCT LIKE 'PRODUCT2%')

SELECT REGIONID, PRODUCT, ROUND(AVG(QTY)) AS AVG_QTY
FROM KOPO_RESULT1
GROUP BY REGIONID, PRODUCT 

SELECT REGIONID, PRODUCT, ROUND(AVG(QTY)) AS AVG_QTY
FROM (SELECT *
                FROM KOPO_CHANNEL_SEASONALITY_NEW
                WHERE YEARWEEK != 53 
                AND LEFT(YEARWEEK,4) >= 2015 
                AND (PRODUCT LIKE 'PRODUCT1%' OR PRODUCT LIKE 'PRODUCT2%')) AS KOPO_RESULT1
GROUP BY REGIONID, PRODUCT;
 


##############################  서브쿼리 (sub query)  ##################################

-- FROM 절의 서브쿼리
SELECT B.*,
	ROUND( B.MAPE_ACCURACY, 2) AS ROUND_ACCURACY
FROM(
		SELECT
			A.*,
			1 - ABS(A.FCST - A.ACTUAL) / A.FCST AS MAPE_ACCURACY
		FROM RMSE_MAE_EXAMPLE A
	)B
	
-- WHERE 절의 서브쿼리
SELECT *
FROM KOPO_CHANNEL_SEASONALITY_NEW
WHERE REGIONID IN (
					SELECT 
						DISTINCT REGIONID AS SUBSIDIARY
					FROM KOPO_PRODUCT_VOLUME
				   )
