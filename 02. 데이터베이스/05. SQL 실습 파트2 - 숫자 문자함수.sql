#################### 복원된 데이터베이스에서 시작 ##########################
DROP TABLE KOPO_RECALL_ITEM

SELECT *
FROM KOPO_RECALL_ITEM

# 테이블 생성
CREATE TABLE KOPO_RECALL_ITEM(
	ITEM VARCHAR(100),
	ITEM_DESC VARCHAR(100)
)

# 데이터 조회
SELECT *
FROM KOPO_RECALL_ITEM

# 데이터 삭제
DELETE FROM KOPO_RECALL_ITEM

# 데이터 삽입
INSERT INTO KOPO_RECALL_ITEM
VALUES ('ITEM04013', '전원고장'), ('ITEM011124', '패널고장')

# 데이터 수정
UPDATE KOPO_RECALL_ITEM
SET ITEM_DESC = '전원제어부 고장'
WHERE ITEM = 'ITEM04013'

# 데이터 조회 (BETWEEN, IN, IS NULL)
SELECT * 
FROM KOPO_PROMOTION
WHERE ITEM = (  KOPO_RECALL_ITEM 테이블 에 존재하는 ITEM )

SELECT * 
FROM KOPO_PROMOTION
WHERE ITEM IN (  SELECT DISTINCT ITEM

FROM KOPO_RECALL_ITEM )
	

#################### 1. 문자함수 ##########################

### 대문자/소문자
SELECT 
	UPPER(PRODUCT) AS CASE1,
	LOWER(PRODUCT) AS CASE2
FROM KOPO_CHANNEL_SEASONALITY

### 문자 합치기
SELECT 
	CONCAT( A.REGIONID,'_',A.PRODUCT) AS IDX,
	A.*
FROM KOPO_CHANNEL_SEASONALITY_NEW A	

SELECT 
	CONCAT( A.REGIONID,'_',A.PRODUCT) AS IDX,
	A.*
FROM KOPO_CHANNEL_SEASONALITY_NEW A

### 문자 추출
SELECT A.*,
	SUBSTR(A.PRODUCT,8,2) AS PRODUCT_ID,
	SUBSTR(A.YEARWEEK,1,4) AS YEAR,
	SUBSTR(A.YEARWEEK,5,2) AS WEEK
FROM KOPO_CHANNEL_SEASONALITY_NEW A

## 문제해결방법: 상품코드가 7자리가 PREFIX 뒤에 시리얼번호 3자리까지 사용
## 문제 시리얼번호를 남기고 10자리로 앞에 P를 붙여라!
## STEP1: 상품코드를 전부 대문자로 변환
## STEP2: 상품코드 8자리부터 시리얼번호 추출 (최대 3자리)
## STEP3: 추출된 상품코드를 10자리로 맞춤 (왼쪽에 "P"코드 붙이기)

SELECT  A.*,
		UPPER( A.PRODUCT ) AS UPPER_LOWER, 
		SUBSTR( UPPER( A.PRODUCT ), 8, 3 ) AS EXTRACT_SERIAL,
		LPAD( SUBSTR( UPPER( A.PRODUCT ), 8, 3 ), 10, "P") AS NEW_CODE
FROM KOPO_CHANNEL_SEASONALITY_NEW A

### 트림

CREATE TABLE USERS
( id int,
 username varchar(100))
 
 INSERT INTO USERS VALUES
 (1,' john_doe'),
 (2,'jane_smith'),
 (3,' robert_james')
 
 ### TRIM을 써야지만!!! 조회가 가능하다!
 ### 함수는 컬럼에 사용하지만 WHERE 조건에도 사용가능하다!!!
 SELECT id,
 username
 FROM USERS
 WHERE TRIM(username) = 'john_doe'
 
 ### REPLACE (교체)
 SELECT A.*,
 	REPLACE(A.REGIONID,'A','REGION_')
 FROM KOPO_PRODUCT_VOLUME A
 

#KOPO_CUSTOMERDATA의 고객코드는10자리이다
#만약 10자리가 아니면 왼쪽에 0으로 채운다
#이후 고객코드의 뒷 4자리는 암호화를 위해 * 처리를
#해야합니다.
    
SELECT CUSTOMERCODE,
        LPAD( CUSTOMERCODE, 10, '0') AS CUSTOMERCODE_10,
        SUBSTR( LPAD( CUSTOMERCODE, 10, '0'), 7, 4),
        REPLACE ( LPAD( CUSTOMERCODE, 10, '0'), SUBSTR( LPAD( CUSTOMERCODE, 10, '0'), 7, 4), '****') AS ENCRYPTED_CUSTOMERCODE
FROM KOPO_CUSTOMERDATA

#################### 2. 숫자함수 ##########################

SELECT * 
FROM NUMBER_EXAMPLE

SELECT A.*,
	A.FISRT_NUMBER / A.SECOND_NUMBER AS DIVISION,
	ROUND(A.FISRT_NUMBER / A.SECOND_NUMBER,2) AS ROUND_DIV,
	CEIL(A.FISRT_NUMBER / A.SECOND_NUMBER) AS CEIL_DIV,
	FLOOR(A.FISRT_NUMBER / A.SECOND_NUMBER) AS FLOOR_DIV,
	MOD(A.FISRT_NUMBER,A.SECOND_NUMBER) AS MOD_DIV,
	POWER(A.FISRT_NUMBER,A.SECOND_NUMBER) AS POW_DIV
FROM NUMBER_EXAMPLE A

### RMSE_MAE_EXAMPLE 테이블에서
### ACCURACY =1 – ABS(예측값-실제값) / 예측값 
### 공식을 활용하여
### 정확도를 산출하세요 (소수점 2째자리 반올림)

SELECT A.*,
	   ROUND( 1-ABS(A.FCST-A.ACTUAL) / A.FCST,2)
FROM RMSE_MAE_EXAMPLE A

#### 만약?... FCST가 0 이 있다면?

CREATE TABLE RMSE_MAE_EXAMPLE2 AS
SELECT *
FROM RMSE_MAE_EXAMPLE

INSERT INTO RMSE_MAE_EXAMPLE2
(FCST) VALUES (0)

SELECT A.*,
	   ABS(A.FCST-A.ACTUAL) / A.FCST AS ACCURACY
FROM RMSE_MAE_EXAMPLE2 A
WHERE A.FCST = 0
